\chapter{Специальная часть}
\section{Постановка задачи}
\label{sec:spec:ProblemDefinition}
Разработать метод мониторинга состояния ЛА на основе методов интеллектуального анализа данных. Реализовать программную систему, использующую данный метод.

Система должна удовлетворять следующим требованиям:
\begin{itemize}
	\item строить модель системы только на основе телеметрии при различных режимах её работы, без априорных данных о предметной области, назначении системы, её составе, конструкции (обучение без учителя);
	\item обладать способностью классифицировать аномалии в работе системы;
	\item в случае, если текущее поведение системы не было представлено в обучающей выборке, давать оператору численную характеристику отклонения системы от номинальных режимов;
	\item обрабатывать большие массивы входных данных (несколько десятков тысяч точек) за конечное время;
	\item учитывать как непрерывные, так и дискретные параметры системы;
	\item не иметь ограничений на закон распределения входных данных;
	\item быть устойчивой к аномалиям в обучающей выборке;
	\item быть устойчивой к отсутствию значений каких-либо параметров во входных данных;
	\item определять состояние системы в режиме реального времени.
\end{itemize}

\section{Анализ существующих методов выявления аномалий без учителя}
На данный момент существует несколько методов, для которых доказана возможность применения их в системах контроля и диагностики ЛА. Такими методами являются Orca, GritBot, GMM (Gaussian Mixture Model), DBN (Dynamic Bayesian Network), One-Class SVM (Support Vector Machine) и IMS (Inductive Monitoring System)~\cite{MartinCompUnsupervisedDetectionMethods}.

\input{./special/subsections/orca}

\input{./special/subsections/gritbot}

\input{./special/subsections/gmm}

\input{./special/subsections/dbn}

\input{./special/subsections/svm}

\input{./special/subsections/ims}

\section{Разработка метода мониторинга состояния ЛА на основе методов интеллектуального анализа данных}

Все описанные выше методы имеют свои недостатки при их применении для диагностики сложных технических систем. Сравнение методов по критериям, указанным в разделе~\ref{sec:spec:ProblemDefinition}, приведено в таблице~\ref{tab:spec:MethodsComparison}.

\begin{table}[h]
\caption{Сравнение методов выявления аномалий без учителя}
\label{tab:spec:MethodsComparison}

\begin{tabular}{|C{210pt}|C{35pt}|C{45pt}|C{38pt}|C{35pt}|C{36pt}|C{35pt}|}
\hline
\backslashbox{Критерий}{Метод} & Orca & GritBot & GMM & DBN & SVM & IMS \\
\hline
Построение модели системы без априорных данных о предметной области, назначении системы, её составе, конструкции & + & + & ± & + & − & + \\
\hline
Классификация аномалий & − & − & − & + & − & − \\
\hline
Численная характеристика аномалии & + & − & − & − & + & + \\
\hline
Обработка больших выборок за конечное время & ± & − & ± & + & + & + \\
\hline
Работа с дискретными параметрами & + & + & − & ± & − & − \\
\hline
Отсутствие ограничений на закон распределения входных данных & + & + & − & ± & + & + \\
\hline
Устойчивость к аномалиям в обучающей выборке & + & + & − & − & − & − \\
\hline
Устойчивость к отсутствию значений параметров во входных данных & + & + & − & − & − & + \\
\hline
Работа в режиме реального времени & − & − & + & + & + & + \\
\hline
\end{tabular}
\end{table}

По результатам сравнения наиболее подходящим является метод IMS, описанный в подразделе~\ref{subsec:spec:IMS}. Так как он не удовлетворяет всем требованиям, указанным в разделе~\ref{sec:spec:ProblemDefinition}, необходимо создать на его основе метод, устойчивый к аномалиям в обучающей выборке, обеспечивающий возможность классификации аномалий и работающий не только с непрерывными, но и с дискретными параметрами.

\input{./special/subsections/ddms}

\section{Выбор программных средств реализации метода}

К языку программирования и программной платформе в данной работе предъявлялись следующие требования:
\begin{itemize}
	\item поддержка объектно-ориентированной парадигмы;
	\item удобство использования (скорость разработки);
	\item возможность повторного использования кода;
	\item быстродействие.
\end{itemize}

Рассмотрим подробнее каждое из требований.

\subsection{Предъявляемые требования}
\subsubsection{Поддержка объектно-ориентированной парадигмы}
Объектно-ориентированне программирование (ООП)~---~парадигма программирования, в которой основными концепциями являются понятия объектов и классов. В случае языков с прототипированием вместо классов используются объекты-прототипы. В центре ООП находится понятие объекта. Объект~---~это сущность, которой можно посылать сообщения и которая может на них реагировать, используя свои данные. Объект~---~это экземпляр класса. Данные объекта скрыты от остальной программы (инкапсулированы).
Наличие инкапсуляции достаточно для объектности языка программирования, но ещё не означает его объектной ориентированности~---~для этого требуется наличие наследования.
Но даже наличие инкапсуляции и наследования не делает язык программирования в полной мере объектным с точки зрения ООП. Основные преимущества ООП проявляются только в том случае, когда в языке программирования реализован полиморфизм; то есть возможность объектов с одинаковой спецификацией иметь различную реализацию.

Основные концепции и понятия ООП представлены ниже.

\uline{Абстрагирование}~---~это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция — это набор всех таких характеристик.

\uline{Инкапсуляция}~---~это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе, и скрыть детали реализации от пользователя.

\uline{Наследование}~---~это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом; новый класс~---~потомком, наследником или производным классом.

\uline{Полиморфизм}~---~это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

\uline{Класс}~---~описываемая на языке терминологии (пространства имён) исходного кода модель ещё не существующей сущности (объекта). Фактически он описывает устройство объекта, являясь своего рода чертежом. Говорят, что объект~---~это экземпляр класса. При этом в некоторых исполняющих системах класс также может представляться некоторым объектом при выполнении программы посредством динамической идентификации типа данных. Обычно классы разрабатывают таким образом, чтобы их объекты соответствовали объектам предметной области.

\uline{Объект}~---~сущность в адресном пространстве вычислительной системы, появляющаяся при создании экземпляра класса или копирования прототипа (например, после запуска результатов компиляции и связывания исходного кода на выполнение).

\uline{Прототип}~---~объект-образец, по образу и подобию которого создаются другие объекты. Объекты-копии могут сохранять связь с родительским объектом, автоматически наследуя изменения в прототипе; эта особенность определяется в рамках конкретного языка.~\cite{PaisonOOP}

Основными принципы объектно-ориентированного проектирования представлены ниже. Данный набор принципов принято обозначать аббревиатурой \textit{SOLID}.

\uline{Принцип единственной обязанности} (Single Responsibility Principle): каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности. Таким образом, класс или модуль должны иметь одну и только одну причину измениться.

\uline{Принцип открытости/закрытости} (Open/Closed Principle): программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что такие сущности могут позволять менять свое поведение без изменения их исходного кода.

\uline{Принцип подстановки Барбары Лисков} (Liskov Substitution Principle): объекты в программе могут быть заменены их наследниками без изменения свойств программы. Функции, которые используют базовый тип, должны иметь возможность использовать подтипы (наследники) базового типа, не зная об этом.

\uline{Принцип разделения интерфейса} (Interface Segregation Principle): клиенты не должны зависеть от методов, которые они не используют. Интерфейсы, содержащие слишком много полей и методов, необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

\uline{Принцип инверсии зависимостей} (Dependency Inversion Principle): зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.~\cite{RMartinAgile}

Применение объектно-ориентированной парадигмы позволяет улучшить понимание исходного кода, упростить его дальнейшую поддержку, использование и усовершенствование, так как модули и классы в коде представляют собой проекции реальных объектов предметной области. В частности, в проектируемой системе такими объектами являются модель системы, режимы работы, кластеры, входные векторы и т.д.